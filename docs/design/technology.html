<!DOCTYPE html>
<html class="no-js" lang="en">

<head>
<title>技术实现 &bull; Fusion DiscoveryX</title>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<meta name="description" content="discoveryx-docs"/>
<link rel="canonical" href="https://akka-fusion.github.io/fusion-discoveryx/design/technology.html"/>
<script type="text/javascript" src="../lib/jquery/jquery.min.js"></script>
<script type="text/javascript" src="../lib/foundation/dist/js/foundation.min.js"></script>
<link rel="stylesheet" type="text/css" href="../lib/normalize.css/normalize.css"/>
<link rel="stylesheet" type="text/css" href="../lib/foundation/dist/css/foundation.min.css"/>
<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.css" />
<link rel="stylesheet" type="text/css" href="../css/icons.css"/>
<link rel="stylesheet" type="text/css" href="../css/page-6.css"/>
<link rel="stylesheet" type="text/css" href="../css/banner.css"/>
<link rel="shortcut icon" href="../images/favicon.ico" />
<link rel="apple-touch-icon" sizes="180x180" href="../images/apple-touch-icon.png"/>
<link rel="icon" type="image/png" sizes="32x32" href="../images/favicon-32x32.png"/>
<link rel="icon" type="image/png" sizes="16x16" href="../images/favicon-16x16.png"/>
<link rel="manifest" href="../images/manifest.json"/>
<meta name="msapplication-TileImage" content="../images/mstile-150x150.png"/>
<meta name="msapplication-TileColor" content="#15a9ce"/>
<meta name="theme-color" content="#15a9ce"/>
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"/>


<body id="underlay" data-toggler="nav-open">
<header class="site-header hide-for-large">
<div class="sticky-header clearfix">
<a href="https://akka.io"><img class="logo" src="../images/akka-logo-reverse.svg"/></a>

<button class="menu-icon float-right" type="button" data-toggle="underlay overlay"></button>
</div>
<div id="overlay" class="overlay-nav" data-toggler="nav-open">
<header class="nav-header">
<div class="nav-header-title">
<h1><a href="../index.html">Fusion DiscoveryX</a></h1>
</div>
<div class="nav-header-version">
Version 1.0.0
</div>
<div class="nav-header-groups">
<select class="supergroup" name="Language"><option class="group" value="group-scala">Scala</option></select>
</div>
</header>
<nav class="nav-toc">
<ul>
  <li><a href="../intro.html" class="page">介绍</a></li>
  <li><a href="../use/index.html" class="page">使用</a></li>
  <li><a href="../design/index.html" class="page">设计</a>
  <ul>
    <li><a href="../design/concept.html" class="page">DiscoveryX 概念</a></li>
    <li><a href="../design/architecture.html" class="page">架构</a></li>
    <li><a href="../design/technology.html#技术实现" class="active page">技术实现</a>
    <ul>
      <li><a href="../design/technology.html#protocol" class="header">Protocol</a></li>
      <li><a href="../design/technology.html#akka-http" class="header">Akka HTTP</a></li>
      <li><a href="../design/technology.html#actor" class="header">Actor</a></li>
      <li><a href="../design/technology.html#cluster" class="header">Cluster</a></li>
      <li><a href="../design/technology.html#persistence" class="header">Persistence</a></li>
    </ul></li>
  </ul></li>
  <li><a href="../api/index.html" class="page">API</a></li>
  <li><a href="../deploy/index.html" class="page">部署</a></li>
  <li><a href="../releases.html" class="page">发布</a></li>
</ul>
</nav>
</div>
</header>
<div class="site-content-wrapper">
<aside class="sticky-sidebar show-for-large">
<header class="nav-header sticky-sidebar-header">
<div class="nav-header-title">
<h1><a href="../index.html">Fusion DiscoveryX</a></h1>
</div>
<div class="nav-header-version">
Version 1.0.0
</div>
<div class="nav-header-groups">
<select class="supergroup" name="Language"><option class="group" value="group-scala">Scala</option></select>
</div>
</header>
<nav class="site-nav sticky-sidebar-contents">
<div class="nav-toc">
<ul>
  <li><a href="../intro.html" class="page">介绍</a></li>
  <li><a href="../use/index.html" class="page">使用</a></li>
  <li><a href="../design/index.html" class="page">设计</a>
  <ul>
    <li><a href="../design/concept.html" class="page">DiscoveryX 概念</a></li>
    <li><a href="../design/architecture.html" class="page">架构</a></li>
    <li><a href="../design/technology.html#技术实现" class="active page">技术实现</a>
    <ul>
      <li><a href="../design/technology.html#protocol" class="header">Protocol</a></li>
      <li><a href="../design/technology.html#akka-http" class="header">Akka HTTP</a></li>
      <li><a href="../design/technology.html#actor" class="header">Actor</a></li>
      <li><a href="../design/technology.html#cluster" class="header">Cluster</a></li>
      <li><a href="../design/technology.html#persistence" class="header">Persistence</a></li>
    </ul></li>
  </ul></li>
  <li><a href="../api/index.html" class="page">API</a></li>
  <li><a href="../deploy/index.html" class="page">部署</a></li>
  <li><a href="../releases.html" class="page">发布</a></li>
</ul>
</div>
</nav>
<footer class="nav-footer sticky-sidebar-footer">
<a href="https://akka.io"><img class="logo" src="../images/akka-logo-reverse.svg"/></a>

</footer>
</aside>
<main class="fixed-shift-for-large expanded row">
<section class="site-content small-12 column">
<article class="page-content row">
<div class="small-12 column" id="docs">
<h1><a href="#技术实现" name="技术实现" class="anchor"><span class="anchor-link"></span></a>技术实现</h1>
<h2><a href="#protocol" name="protocol" class="anchor"><span class="anchor-link"></span></a>Protocol</h2>
<h3><a href="#grpc" name="grpc" class="anchor"><span class="anchor-link"></span></a>gRPC</h3>
<p>DiscoveryX 使用 gRPC 作为内部及开放API的数据通信协议，Akka gRPC提供了 gRPC/Protobuf 与 Akka 的集成。</p>
<p>Naming服务可通过gRPC服务描述语言进行定义，Akka gRPC将生成相应的Scala/Java代码及服务接口。</p>
<pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/yangbajing/fusion-discoveryx/tree/master/discoveryx-common/src/main/protobuf/fusion/discoveryx/grpc/discoveryx.proto#L41-L82" target="_blank" title="Go to snippet source"></a><code class="language-proto">service NamingService {
    // 查询实例
    rpc QueryInstance (fusion.discoveryx.model.InstanceQuery) returns (fusion.discoveryx.model.NamingReply) {
    }

    // 注册实例
    rpc RegisterInstance (fusion.discoveryx.model.InstanceRegister) returns (fusion.discoveryx.model.NamingReply) {
    }

    // 修改实例
    rpc ModifyInstance (fusion.discoveryx.model.InstanceModify) returns (fusion.discoveryx.model.NamingReply) {
    }

    // 删除实例
    rpc RemoveInstance (fusion.discoveryx.model.InstanceRemove) returns (fusion.discoveryx.model.NamingReply) {
    }

    // 实例心跳消息。namespace, serviceName, ip, port, instanceId等使用metadata（HTTP Header发送）
    //- `x-discoveryx-namespace`：命名空间
    //- `x-discoveryx-service-name`：服务名
    //- `x-discoveryx-ip`：服务监听IP地址
    //- `x-discoveryx-port`：服务监听网络端口
    //- `x-discoveryx-instance-id`：实例ID
    rpc Heartbeat (stream fusion.discoveryx.model.InstanceHeartbeat) returns (stream fusion.discoveryx.model.ServerStatusBO) {
    }

    // 查询服务状态
    rpc ServerStatus (fusion.discoveryx.model.ServerStatusQuery) returns (fusion.discoveryx.model.ServerStatusBO) {
    }
}</code></pre>
<h3><a href="#protobuf" name="protobuf" class="anchor"><span class="anchor-link"></span></a>Protobuf</h3>
<p>DiscoveryX 使用 Protobuf 来定义和序列化数据消息，服务需要的请求参数、响应结果通过Protobuf定义，它将被自动编译并生成相应的case class。</p>
<pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/yangbajing/fusion-discoveryx/tree/master/discoveryx-common/src/main/protobuf/fusion/discoveryx/model/discoveryx.proto#L115-L136" target="_blank" title="Go to snippet source"></a><code class="language-proto">message Instance {
    // unique id of this instance.
    string instance_id = 1;
    // Service information of instance
    string namespace = 2;
    string service_name = 3;
    string group_name = 4;
    // instance ip
    string ip = 5;
    // instance port
    int32 port = 6;
    // instance weight
    double weight = 7;
    // instance health status
    bool healthy = 8;
    // If instance is enabled to accept request
    bool enabled = 9;
    // If instance is ephemeral
    bool ephemeral = 10;
    // user extended attributes
    map&lt;string, string&gt; metadata = 11;
}</code></pre>
<h3><a href="#grpc-powerapi" name="grpc-powerapi" class="anchor"><span class="anchor-link"></span></a>gRPC PowerApi</h3>
<p>Akka gRPC在生成服务时有两种选择：</p>
<ol>
  <li>配置服务，生成的Scala/Java服务签名与 gRPC 定义一一对应</li>
  <li>PowerApi，生成的Scala/Java服务多带一个<code>metadata</code>参数，可在定义的数据请求这外使用HTTP Header。这很有用，意味着通常使用的基于 Cookie 和 HTTP Header 的用户认证、Trace等技术可继续使用。</li>
</ol>
<p>对于 <code>heartbeat</code> 这个服务，它的服务端实现如下：</p>
<pre class="prettyprint"><code class="language-scala">  override def heartbeat(
      in: Source[InstanceHeartbeat, NotUsed],
      metadata: Metadata): Source[ServerStatusBO, NotUsed] = {
    try {
      val namespace = metadata
        .getText(Headers.NAMESPACE)
        .getOrElse(throw HSBadRequestException(s&quot;Request header missing, need &#39;${Headers.NAMESPACE}&#39;.&quot;))
      // ....
      // ....
      in.map { _ =&gt;
        namingRegion ! ShardingEnvelope(entityId, Heartbeat(namespace, serviceName, instanceId))
        ServerStatusBO(IntStatus.OK)
      }
    } catch {
      case e: Exception =&gt;
        logger.warn(s&quot;Receive heartbeat message error: $e&quot;)
        Source.single(ServerStatusBO(IntStatus.BAD_REQUEST))
    }
  }
</code></pre>
<p>对于服务心跳保持这个服务，gRPC 的 stream 特性可实现全双工通信。一旦请求建立连接，我们不需要在每个心跳请求里都重复包含<code>namespace</code>、<code>serviceName</code>、<code>ip</code>和<code>port</code>字段，只需要在第一次请求时发送即可，之后的每次心跳只需要发送一个空请求即可。客户端调用代码使用 <code>StreamResponseRequestBuilder</code> 将参数通过HTTP Header传入。</p>
<pre class="prettyprint"><code class="language-scala">  def heartbeat(in: Source[InstanceHeartbeat, NotUsed], inst: Instance): Source[ServerStatusBO, NotUsed] = {
    namingClient
      .heartbeat()
      .addHeader(Headers.NAMESPACE, inst.namespace)
      .addHeader(Headers.SERVICE_NAME, inst.serviceName)
      .addHeader(Headers.IP, inst.ip)
      .addHeader(Headers.PORT, Integer.toString(inst.port))
      .addHeader(Headers.INSTANCE_ID, inst.instanceId)
      .invoke(in)
  }
</code></pre>
<h2><a href="#akka-http" name="akka-http" class="anchor"><span class="anchor-link"></span></a>Akka HTTP</h2>
<h3><a href="#通过-akka-http-发布-grpc-服务" name="通过-akka-http-发布-grpc-服务" class="anchor"><span class="anchor-link"></span></a>通过 Akka HTTP 发布 gRPC 服务</h3>
<p>gRPC当前是基于HTTP 2的，Akka HTTP也支持HTTP 2，我们可以通过 Akka HTTP 来发布 gRPC 服务。通过 <code>[ServiceName]Handler</code> 提供的方法来构造 gRPC handler，有两种方式：</p>
<ol>
  <li><code>apply</code>，返回一个函数，签名：<code>HttpRequest =&gt; Future[HttpResponse]</code></li>
  <li><code>partial</code>，返回一个偏函数，签名：<code>PartialFunction[HttpRequest, Future[HttpResponse]]</code></li>
</ol>
<pre class="prettyprint"><code class="language-scala">val managementService = new ManagementServiceImpl()
val handler: HttpRequest =&gt; Future[HttpResponse] = ManagementServiceHandler(managementService)
val grpcHandler: PartialFunction[HttpRequest, Future[HttpResponse]] = ManagementServiceHandler.partial(managementService)
</code></pre>
<p>连接多个 gRPC handler：</p>
<pre class="prettyprint"><code class="language-scala">ServiceHandler.concatOrNotFound(grpcHandlers: _*)
</code></pre><div class="callout note "><div class="callout-title">Note</div>
<p>始终使用 <code>.partial</code> 构造单个 gRPC 服务 handler，再用 <code>ServiceHandler.concatOrNotFound()</code> 合并起来</p></div>
<h3><a href="#给-grpc-服务提供-rest-api" name="给-grpc-服务提供-rest-api" class="anchor"><span class="anchor-link"></span></a>给 gRPC 服务提供 REST API</h3>
<h4><a href="#directive-指令" name="directive-指令" class="anchor"><span class="anchor-link"></span></a>Directive 指令</h4>
<p>Akka HTTP 提供了 Directive（指令）DSL来构造 HTTP API 路由。</p>
<pre class="prettyprint"><code class="language-scala">  import fusion.discoveryx.server.util.ProtobufJsonSupport._

  def openRoute: Route = pathPrefix(&quot;config&quot;) {
    pathPost(&quot;GetConfig&quot;) {
      entity(as[ConfigGet]) { in =&gt;
        complete(configService.getConfig(in))
      }
    } ~
    pathPost(&quot;PublishConfig&quot;) {
      entity(as[ConfigItem]) { in =&gt;
        complete(configService.publishConfig(in))
      }
    } ~
    pathPost(&quot;RemoveConfig&quot;) {
      entity(as[ConfigRemove]) { in =&gt;
        complete(configService.removeConfig(in))
      }
    }
  }
</code></pre>
<p>Directive 可以组合</p>
<pre class="prettyprint"><code class="language-scala">def pathPost[L](pm: PathMatcher[L]): Directive[L] = path(pm) &amp; post
</code></pre>
<h4><a href="#marshal-unmarshal" name="marshal-unmarshal" class="anchor"><span class="anchor-link"></span></a>Marshal/Unmarshal</h4>
<p>Marshal/Unmarshal 实现类与 HTTP entity 自动转换，这里 </p>
<pre class="prettyprint"><code class="language-scala">  private val jsonStringUnmarshaller =
    Unmarshaller.byteStringUnmarshaller.forContentTypes(unmarshallerContentTypes: _*).mapWithCharset {
      case (ByteString.empty, _) =&gt; throw Unmarshaller.NoContentException
      case (data, charset)       =&gt; data.decodeString(charset.nioCharset.name)
    }

  private val jsonStringMarshaller =
    Marshaller.oneOf(mediaTypes: _*)(Marshaller.stringMarshaller)

  // HTTP entity =&gt; `A`
  implicit def unmarshaller[A &lt;: GeneratedMessage with Message[A]: GeneratedMessageCompanion](
      implicit parser: Parser = ProtobufJson4s.parser): FromEntityUnmarshaller[A] =
    jsonStringUnmarshaller.map(s =&gt; parser.fromJsonString(s)).recover(throwCause)

  // `A` =&gt; HTTP entity
  implicit def marshaller[A &lt;: GeneratedMessage](
      implicit printer: Printer = ProtobufJson4s.printer,
      shouldWritePretty: ShouldWritePretty = ShouldWritePretty.False): ToEntityMarshaller[A] =
    shouldWritePretty match {
      case ShouldWritePretty.False =&gt; jsonStringMarshaller.compose(a =&gt; JsonMethods.compact(printer.toJson(a)))
      case ShouldWritePretty.True  =&gt; jsonStringMarshaller.compose(a =&gt; JsonMethods.pretty(printer.toJson(a)))
    }
</code></pre>
<h2><a href="#actor" name="actor" class="anchor"><span class="anchor-link"></span></a>Actor</h2>
<h3><a href="#protobuf与typed-actor" name="protobuf与typed-actor" class="anchor"><span class="anchor-link"></span></a>Protobuf与Typed Actor</h3>
<pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/yangbajing/fusion-discoveryx/tree/master/discoveryx-server/src/main/protobuf/fusion/discoveryx/server/protocol/naming.proto#L117-L129" target="_blank" title="Go to snippet source"></a><code class="language-proto">message NamingManagerCommand {
    option (scalapb.message).extends = &quot;fusion.discoveryx.server.naming.NamingManager.Command&quot;;
    option (scalapb.message).companion_extends = &quot;fusion.protobuf.ActorRefCompanion&quot;;

    string reply_to = 1 [(scalapb.field).type = &quot;akka.actor.typed.ActorRef[NamingResponse]&quot;];
    oneof cmd {
        ListService list_service = 2;
        GetService get_service = 3;
        CreateService create_service = 4;
        RemoveService remove_service = 5;
        ModifyService modify_service = 6;
    }
}</code></pre>
<p><code>option (scalapb.message).extends =</code>使消息符合 Typed Actor 的消息类型限制。</p>
<p><code>ActorRefCompaion</code> 提供了<code>reply_to</code>字段从 <code>String</code> 到 <code>ActorRef[NamingResponse]</code> 的相互转换功能。</p>
<pre class="prettyprint"><code class="language-scala">trait ActorRefCompanion {
  private def resolver: ActorRefResolver = ActorRefResolver(ActorSystemUtils.system)

  implicit def actorRefTypeMapper[T]: TypeMapper[String, ActorRef[T]] = {
    TypeMapper[String, ActorRef[T]] { str =&gt;
      if (StringUtils.isBlank(str)) ActorSystemUtils.system.deadLetters[T]
      else resolver.resolveActorRef[T](str)
    } { ref =&gt;
      ref.path.elements match {
        case List(&quot;deadLetters&quot;) =&gt; &quot;&quot; // resolver.toSerializationFormat(ActorSystemUtils.system.deadLetters[T])
        case _                   =&gt; resolver.toSerializationFormat(ref)
      }
    }
  }
}
</code></pre><div class="callout note "><div class="callout-title">Note</div>
<p>多个 gRPC 服务消息通过 <code>oneof</code> 特性合并到一个 protobuf 消息里，这样通常有两个好处：</p>
<ol>
  <li>减少需要通过 <code>option (scalapb.message).extends</code> 定义 protobuf 消息扩展某个接口的次数</li>
  <li>这样可以减少需要通过 <code>[(scalapb.field).type]</code> 自定义 <code>ActorRef[T]</code> 转换的次数。</li>
</ol></div>
<pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/yangbajing/fusion-discoveryx/tree/master/discoveryx-server/src/main/protobuf/fusion/discoveryx/server/protocol/naming.proto#L133-L141" target="_blank" title="Go to snippet source"></a><code class="language-proto">message NamingResponse {
    int32 status = 1;
    string message = 2;
    oneof data {
        ListedService listed_service = 3;
        fusion.discoveryx.model.ServiceInfo service_info = 4;
        fusion.discoveryx.model.Instance instance = 5;
    }
}</code></pre>
<p><code>NamingResponse</code> 作为 <code>reply_to</code> 里 <code>ActorRef[T]</code> 的类型参数，统一了 Actor 的响应。</p>
<ol>
  <li>因为 Actor 之间的异步特性，消息需要有状态码来表示处理是否成功？（<code>status</code>、<code>message</code>）字段</li>
  <li>通过<code>oneof</code>封装实际的业务数据</li>
  <li>通过包装，也更加符合通常REST风格API在响应结果时的风格。</li>
</ol><div class="callout note "><div class="callout-title">Note</div>
<p>Protobuf的<code>oneof</code>特性在序列化为JSON时，将没有外层的<code>data</code>。而是会将具体的消息类型字段返回。如：</p>
<pre class="prettyprint"><code class="language-json">{
  &quot;listedService&quot;: {
    &quot;serviceInfos&quot;: [],
    &quot;page&quot;: 1
  }
}
</code></pre></div>
<h3><a href="#typed-actor" name="typed-actor" class="anchor"><span class="anchor-link"></span></a>Typed Actor</h3>
<p><strong>建议</strong></p>
<ul>
  <li>object（伴身对象）： 内定义消息类型<code>trait</code>、<code>EntityTypeKey</code>、消息等</li>
  <li>class（同名类）： 定义具体的<code>Behavior</code>，若Actor比较简单，也可以在 <code>object.apply</code> 方法里直接实现。</li>
  <li>响应消息里标注操作是否成功</li>
  <li>因为 Actor 是异步的，当<code>ask</code>超时时异常不应被吞掉，应将异常转换并构造成消息返回</li>
</ul>
<pre class="prettyprint"><code class="language-scala">val response = try {
  // ...
} catch {
  case e =&gt; NamingResponse(IntStatus.INTERNAL_ERROR, e.getMessage)
}
replyTo ! response

////////////////////////////////////////////////////////////////////////////////

processCreate(in).recover {
  case e =&gt; NamingResponse(IntStatus.INTERNAL_ERROR, e.getMessage)
}.foreach(response =&gt; replyTo ! response)
</code></pre>
<h2><a href="#cluster" name="cluster" class="anchor"><span class="anchor-link"></span></a>Cluster</h2>
<p><img src="imgs/FusionDiscoveryXClassDiagram.svg" alt="Actor 类图" /></p>
<h3><a href="#sharding" name="sharding" class="anchor"><span class="anchor-link"></span></a>Sharding</h3>
<p>通过分片可横向扩展服务Actor（NamingManager、ServiceInstance、ConfigEntity、ConfigManager），一个<code>entityId</code>将保证同一时间内整个集群中只有一个实例，同时由集群选择在哪一个节点创建这个实例。</p>
<ul>
  <li>具备横向扩展能力</li>
  <li>地址透明，不需要关心节点、网络地址等，通过 <code>entityId</code> 构造 <code>ShardingEnvelope</code> 发送消息即可</li>
</ul>
<h4><a href="#shardingenvelope" name="shardingenvelope" class="anchor"><span class="anchor-link"></span></a>ShardingEnvelope</h4>
<p>向分片 Actor 发送消息的载体。NamingManager 可以保存它所能管理的所有 ServiceInstance 的 <code>entityId</code>（&lsquo;[namespace] [serviceName]&rsquo;）。</p>
<p>不需要保存 ServiceInstance 的 Actor 引用，通过 <code>ShardingEnvelope</code> 和 <code>entityId</code> 即可向 ServiceInstance 发送消息。</p><div class="callout note "><div class="callout-title">应用场景</div>
<p>ServiceInstance向ServiceManager注册自己</p></div>
<h3><a href="#singleton" name="singleton" class="anchor"><span class="anchor-link"></span></a>Singleton</h3>
<p>Primary/Secondary 模式下用来实现 Primary 了。</p>
<p><code>Management</code>（管理Actor）作为一个Singleton。</p>
<ol>
  <li>通过 Singleton Actor 来实现管理功能，保存所有有效的 namespace 列表</li>
  <li>通过 <code>ReadJournal</code> 查询、监听 <strong>Event</strong> ，管理 <code>NamingManager</code> 保存的 <code>serviceNames</code> 列表 和 <code>ConfigManager</code> 保存的 <code>configKeys</code> 列表</li>
</ol>
<h3><a href="#distributedata" name="distributedata" class="anchor"><span class="anchor-link"></span></a>DistributeData</h3>
<p>通过 DistributeData 在每个节点同步 namespace 列表，Config、Naming 相关功能校验 namespace 是否有效时实现本地校验（不需要通过网络请求）</p>
<h2><a href="#persistence" name="persistence" class="anchor"><span class="anchor-link"></span></a>Persistence</h2>
<p>数据持久化</p>
<h3><a href="#eventsourcebehavior" name="eventsourcebehavior" class="anchor"><span class="anchor-link"></span></a>EventSourceBehavior</h3>
<pre><code>Command -&gt; Event -&gt; State
</code></pre>
<p>通过处理 <code>Command</code> 生成 <code>Event</code>，<code>Event</code> 将用于改变保存的 <code>State</code> （内存中），而每一个 <code>Event</code> 将被持久化。恢复时可通过重放 <code>Event</code> 来恢复 <code>State</code>。</p>
<ul>
  <li>PersistenceId: 使用 EntityTypeKey.name 和 entityId 一起，保证持久化ID的唯一性</li>
  <li>恢复时会自动重放所有持久事件</li>
</ul>
<p>EventSourceBehavior 可以与普通的 Behavior 集成</p>
<ul>
  <li>与 ClusterSharding 集成，保证每个 PersistenceId 在整个集群内同一时间只会有一个实例</li>
  <li>与 ClusterSingleton 集成，保证当前 PersistenceId 在整个集群内同一时间只有一个实例（<code>Management</code>）</li>
</ul>
<h3><a href="#存储的选择" name="存储的选择" class="anchor"><span class="anchor-link"></span></a>存储的选择</h3>
<ul>
  <li>JDBC：开发环境搭建方便，但性能略差</li>
  <li>Cassandra：性能好，开发环境稍麻烦</li>
</ul>
<p><em>通过 Docker 来自动化创建开发环境</em></p>
<h3><a href="#snapshot" name="snapshot" class="anchor"><span class="anchor-link"></span></a>Snapshot</h3>
<p>通过创建快照可以加快恢复时的速度。</p>
<p>快照被触发时将保存当前 <code>State</code>。恢复时将以被保存的 <code>State</code> 来初始化状态，同时将快照后的事件进行重放，以将持久化Actor恢复到其当前（既最新）的状态。</p>
<h3><a href="#readjournal" name="readjournal" class="anchor"><span class="anchor-link"></span></a>ReadJournal</h3>
<p>CQRS架构的查询取端（也称“读取端”）。</p>
<p>写、读的分离。监听 Event 事件，更新ConfigManager保存的dataId列表</p><div class="callout note "><div class="callout-title">建议</div>
<p>应通过 ReadJournal 将事件数据整合后迁移到查询端数据库（比如：Elasticsearch、RDBMS……），由另一个系统来提供更丰富的查询功能。</p></div>
</div>
</article>
<div class="row">
<div class="small-12 column">
<section class="nav-prev-next row">
<div class="nav-prev small-6 column">
<a href="../design/architecture.html"><i class="icon-prev"></i> <span class="link-prev">架构</span></a>
</div>
<div class="nav-next small-6 column clearfix">
<a class="float-right" href="../api/index.html">API <i class="icon-next"></i></a>
</div>
</section>
</div>
</div>
<div class="source-github row">
在此文档中发现错误？该页面的源代码可以在 <a href="https://github.com/yangbajing/fusion-discoveryx/tree/master/discoveryx-docs/src/main/paradox/design/technology.md" target="_blank">这里</a> 找到。欢迎随时编辑并提交Pull Request。
</div>

<footer class="page-footer row clearfix">
<img class="akka-icon float-left show-for-medium" src="../images/akka-icon.svg" />
<section class="copyright">
<div>discoveryx-docs is Open Source and available under the Apache 2 License.</div>
<p class="legal">
&copy; 2019-2019 <a href="https://akka-fusion.github.com/" target="_blank">Akka Fusion</a> |
<a href="https://akka-fusion.github.com/fusion-discoveryx/" target="_blank">Fusion DiscoveryX</a> |
<a href="https://akka-fusion.github.com/fusion-schedulerx/" target="_blank">Fusion SchedulerX</a>
</p>
</section>
</footer>
</section>
</main>
</div>

<script type="text/javascript" src="../js/scrollsneak.js"></script>
<script type="text/javascript">jQuery(document).foundation();</script>
<script type="text/javascript" src="../js/groups.js"></script>
<script type="text/javascript" src="../js/page.js"></script>
<script type="text/javascript" src="../js/magellan.js"></script>
<script type="text/javascript" src="../js/metadata-toggle.js"></script>

<style type="text/css">@import "../lib/prettify/prettify.css";</style>
<script type="text/javascript" src="../lib/prettify/prettify.js"></script>
<script type="text/javascript" src="../lib/prettify/lang-scala.js"></script>
<script type="text/javascript">//<![CDATA[
jQuery(function(){window.prettyPrint && prettyPrint()});
//]]></script>
<!-- hook for including project specific javascript into the generated docs -->

</body>
</html>
